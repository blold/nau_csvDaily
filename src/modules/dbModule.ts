const EventEmitter = require("events").EventEmitter;

import * as dbConfig from "../configs/dbConfig.json";

const emitter = new EventEmitter();

/**
 * This is the SQL DB class, including getAllData(), getOneData(),
 * getCustomData(), insertData(), deleteOneData(), createTable(), countData(), checkDataExist(), truncate(), dropTable()
 */
export default class SQLDB {
  private database: string;
  private table?: string;
  private host: string;
  private user: string;
  private password: string;
  private con: any;

  /**
   *
   * @param database : default value is userDb
   * @param table : need to pass
   * @param host : default value is 35.225.49.65
   * @param user : default vaue is root
   * @param password : default value is Nauticus209$
   */
  constructor(
    database: string = dbConfig.database,
    table?: string,
    host: string = dbConfig.host,
    user: string = dbConfig.user,
    password: string = dbConfig.password
  ) {
    this.database = database;
    this.host = host;
    this.user = user;
    this.password = password;
    this.table = table;
    this.con = require("knex")({
      client: "mysql",
      connection: {
        host: this.host,
        user: this.user,
        password: this.password,
        database: this.database
      },
      pool: { min: 0, max: 50 }
      // debug: true
    });
  }

  /**
   * create connection to the sql server
   */
  createConnection() {
    return new Promise((resolve, reject) => {
      try {
        this.con = require("knex")({
          client: "mysql",
          connection: {
            host: this.host,
            user: this.user,
            password: this.password,
            database: this.database
          },
          pool: { min: 0, max: 10 }
        });
        resolve(this.con);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * get all data from the db
   * @param {string} table :  default value is class inital table
   */
  getAllData(table = this.table) {
    return new Promise((resolve, reject) => {
      this.con
        .select()
        .from(table)
        .then((results: any) => {
          resolve(results);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   *
   * @param {string} id : the id record generated by the DB
   * @param table
   */
  getOneData(id: string, table = this.table) {
    return new Promise((resolve, reject) => {
      this.con
        .select()
        .from(table)
        .where("id", id)
        .then((results: any) => {
          resolve(results);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   * user can customise the query
   */
  runCustomQuery() {
    return this.con;
  }

  get getEventEmitter() {
    return emitter;
  }

  /**
   * Insert one data into the DB
   * @param object : object that user want to input into the DB
   * @param table
   */
  insertData(object: any, table = this.table) {
    let objectFinal = object;
    objectFinal.created_at = new Date();
    objectFinal.updated_at = new Date();
    return new Promise((resolve, reject) => {
      this.con(table)
        .insert(objectFinal)
        .then((results: any) => {
          if (typeof results[0] === "number") {
            emitter.emit("insertData");
            resolve(true);
          }
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   * Insert a lot of data into the DB
   * @param object
   * @param table
   */
  transacting(object: any, table = this.table) {
    let objectFinal = object;
    objectFinal.created_at = new Date();
    objectFinal.updated_at = new Date();

    return new Promise((resolve, reject) => {
      this.con
        .transaction((trx: any) => {
          this.con(table)
            .transacting(trx)
            .insert(objectFinal)
            .then((resp: any) => {
              // console.log(resp[0]);
              emitter.emit("insertDatas");
              return { id: resp[0], trx };
            })
            .then(trx.commit)
            .catch(trx.rollback);
        })
        .then((d: any) => {
          resolve({ result: true, trx: d.trx });
        })
        .catch((e: any) => {
          throw new Error(e);
          reject(e);
        });
    });
  }

  batchInsert(objectArray: any, table = this.table){
    let chunkSize = 30;
    return new Promise((resolve, reject) => {
      this.con
        .batchInsert(table, objectArray, chunkSize)
        .returning("id")
        .then((d: any) => {
          resolve({ result: true, id: d });
        })
        .catch((e: any) => {
          // throw new Error(e);
          reject(e);
        });
    });
  }

  deleteOneData(id: string, table = this.table) {
    return new Promise((resolve, reject) => {
      this.con(table)
        .where("id", id)
        .del()
        .then((results: any) => {
          if (typeof results === "number") resolve(true);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  createTable(object: any, tableName = this.table) {
    let obKeys = Object.keys(object);
    // let obValues = Object.values(object);
    let obValues = (<any>Object).values(object);
    return new Promise((resolve, reject) => {
      this.con.schema
        .createTable(tableName, function(table: any) {
          table.increments();
          obValues.map((d: string, index: any) => {
            if (typeof d === "number") table.integer(obKeys[index]);
            if (typeof d === "string") table.string(obKeys[index]);
          });
          table.timestamps();
        })
        .then(() => resolve(true))
        .catch((err: any) => {
          reject(err);
        })
        .finally(() => {
          this.con.destroy();
        });
    });
  }

  /**
   * count the record rows from the table
   * @param table
   */
  countData(table = this.table) {
    return new Promise((resolve, reject) => {
      this.con(table)
        .count("id", "active")
        .then((results: any) => {
          resolve({ count: results[0]["count(`id`)"] });
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   * check the data exist or not in the current table
   * @param object
   * @param table
   */
  checkDataExist(object: any, table = this.table) {
    return new Promise((resolve, reject) => {
      this.con(table)
        .where(object)
        .select("id")
        .then((results: any) => {
          // console.log("check");
          if (results.length > 0) {
            let id = results[0].id;
            resolve({ result: true, id });
          } else {
            resolve({ result: false });
          }
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   * clean all data in the table
   * @param table
   */
  truncate(table = this.table) {
    return new Promise((resolve, reject) => {
      this.con(table)
        .truncate()
        .then((results: any) => {
          let result = results[0].protocol41;
          if (result)
            resolve({
              result: true,
              message: results
            });
          else reject({ result: false, message: results });
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /**
   * drop the table in the current DB
   * @param tableName
   */
  dropTable(tableName = this.table) {
    return new Promise((resolve, reject) => {
      this.con.schema
        .dropTable(tableName)
        .then((results: any) => {
          // console.log(results);
          let result = results[0].protocol41;
          resolve({ result });
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  destoryConnect() {
    try {
      this.con.destroy();
      return { result: true };
    } catch (error) {
      // console.log(error);
      return { result: false };
    }
  }
}

// let a5:any = [];
// for(let i = 0; i < 15; i++){
//   let array5 = {
//     TradingVenueId: i,
//     TradeDate: '2018-09-30 00:00:00.0000000',
//     PostingEntryId: 1207983,
//     PostingEntryType: 'Other',
//     PostingEntryDatetime: '2018-09-30 23:55:40.6036366',
//     AccountId: 1212,
//     AccountHandle: '\\N',
//     ProductId: 1,
//     Product: '\\N',
//     CR: 0,
//     DR: 0.012,
//     ReferenceTransactionType: 'Withdraw',
//     ReferenceTransactionId: 109,
//     SystemRecordReference: 20536983,
//     Hdr_ExchangeId: 1,
//     Hdr_ClientSequenceId: 0,
//     Hdr_ClientUserId: 0,
//     CounterpartyAccountId: 2
//   };
//   a5.push(array5)
// }

// let db = new SQLDB("userDb", "acct_entry_hist");
// async function test() {
//   await db.createConnection();
//   let data = await db.transacting(a5);
//   console.log(data);
// }
// test();
